---
layout: post
title: HDU 3007 -- Buried memory
date: 2017-07-11 23:30
comments: true
external-url:
tags: geometry
---

梯度下降法

## 解法

使用梯度下降法。

先定義目標函式：給一平面上座標，輸出該座標與平面上最遠點的距離平方。

我們的任務是將其最小化。

梯度下降：

先隨便選一點，作為起點，向 +x, +y 方向分別跨一小步，
再評估向 +x, +y 移動的目標函式，是否有進步？有則將起點往正向更新位置，否則往反向更新位置。

簡單來說，就是利用 x, y 方向的偏微分，往負的梯度方向前進，就能夠帶我們前往更深的地方（使得目標函式的輸出最小化）。

也就是說，

$$x_{i+1} = x_{i} - f_{x}(x_{i},y_{i})  $$

$$y_{i+1} = y_{i} - f_{y}(x_{i},y_{i})  $$

將 x, y 往 f(x,y) 較低的位置更新。

## 傳送門

[HDU3007](http://acm.hdu.edu.cn/showproblem.php?pid=3007)

## 程式碼

{% highlight cpp linenos=table %}

#pragma GCC target ("avx")
#pragma GCC optimize ("O3")
#include <iostream>
#include <iomanip>
#include <string>
#include <algorithm>
#include <functional>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
using namespace std;

vector< pair<double,double> > cord;

inline double l2(double x, double y) {
    double maxv = 0;
    for (vector< pair<double,double> >::iterator v=cord.begin(); v!=cord.end(); ++v) {
        double dx = v->first-x;
        double dy = v->second-y;
        maxv = max(maxv, dx*dx+dy*dy);
    }
    return maxv; 
}

inline double l1(double x, double y) {
    double maxv = 0;
    for (vector< pair<double,double> >::iterator v=cord.begin(); v!=cord.end(); ++v) {
        double dx = v->first-x;
        double dy = v->second-y;
        maxv = max(maxv, sqrt(dx*dx+dy*dy));
    }
    return maxv; 
}

pair< pair<double, double> , double> brute(int ite, int early_stop=1e9) {
    double initx, inity;
    double eps = 1;
    double momentum = 0.9;
    double delta = 0.95;
    initx = ((double)rand()*2e10/(double)RAND_MAX)-1e10;
    inity = ((double)rand()*2e10/(double)RAND_MAX)-1e10;

    double ori=1e9;
    double min_loss = ori;
    int not_improved = 0;
    for (int i=0; i<ite && not_improved<early_stop; ++i) {
        eps*=delta;
        ori= l2(initx, inity);
        if (ori < min_loss) {
            min_loss = ori;
            not_improved = 0;
        } else {
            ++not_improved;
        }
        double tx = l2(initx+eps, inity);
        double ty = l2(initx, inity+eps);
        initx+=(ori-tx)*momentum;
        inity+=(ori-ty)*momentum;
    }
    return make_pair( make_pair(initx, inity), l1(initx,inity));
}

#define RL() fgets(buff, 4000, stdin)

int main(void) {
    srand(time(NULL));
    int N;
    char buff[4096];
    while((RL())!=NULL) {
        sscanf(buff, "%d", &N);
        if (N==0) break;
        cord.clear();
        for (int i=0; i<N; ++i) {
            double x, y;
            RL();
            sscanf(buff,"%lf%lf", &x, &y);
            cord.push_back(make_pair(x,y));
        }
        pair< pair<double,double> , double> res = brute(1010, 200);
        printf("%.2lf %.2lf %.2lf\n" , res.first.first, res.first.second, res.second);
    }

    return 0;
}

{% endhighlight %}

## 附錄

會吃 TLE 的 退火版



{% highlight cpp linenos=table %}
#pragma GCC target ("avx2")
#pragma GCC optimize ("O3")
#define _USE_MATH_DEFINES
#include <iostream>
#include <iomanip>
#include <string>
#include <algorithm>
#include <functional>
#include <vector>
#include <cstdio>
#include <cstdlib>
#include <cstring>
#include <cmath>
using namespace std;

vector< pair<double,double> > cord;

inline double l2(double x, double y) {
    double maxv = 0;
    for (vector< pair<double,double> >::iterator v=cord.begin(); v!=cord.end(); ++v) {
        double dx = v->first-x;
        double dy = v->second-y;
        maxv = max(maxv, dx*dx+dy*dy);
    }
    return maxv;
}

inline double l1(double x, double y) {
    double maxv = 0;
    for (vector< pair<double,double> >::iterator v=cord.begin(); v!=cord.end(); ++v) {
        double dx = v->first-x;
        double dy = v->second-y;
        maxv = max(maxv, sqrt(dx*dx+dy*dy));
    }
    return maxv;
}

// 模擬退火
pair< pair<double, double> , double> brute(double ite=1e9L,const int early_stop=1e9, const double delta=0.99L, const double coolest=1e-4) {
    double initx, inity;

    int idx = rand()%cord.size();
    initx = cord[idx].first;
    inity = cord[idx].second; // 初始點

    double min_loss = l2(initx, inity); // 初始誤差
    int not_improved = 0;
    while (ite > coolest && not_improved<early_stop) { // 停止條件：若溫度太低 or 超過 not_imported 次數未進步，則停止
        //cout << fixed << setprecision(2) << initx << ' ' << inity << ' ' << min_loss << endl;
        double rd = ((double)rand()/(double)RAND_MAX)*M_PI*2.0L; // 隨機的向量方向 [0, 2*pi)
        double tx = initx + ite*cos(rd), ty = inity + ite*sin(rd); // 原來位置 + 隨機取一向量*(向量長度 == 溫度)
        double loss = l2(tx, ty);
        if (loss < min_loss) {
            initx = tx;
            inity = ty;
            min_loss = loss;
            not_improved = 0;
        } else {
            ite*=delta;
            ++not_improved;
        }
    }
    double res = l1(initx,inity);
    if (abs(initx)<0.005L) initx=0.0L;
    if (abs(inity)<0.005L) inity=0.0L;
    if (abs(res)<0.005L) res=0.0L;
    return make_pair( make_pair(initx, inity), res);
}

#define RL() fgets(buff, 4000, stdin)

int main(void) {
    srand(time(NULL));
    int N;
    char buff[4096];
    while((RL())!=NULL) {
        double max_measure=0;
        sscanf(buff, "%d", &N);
        if (N==0) break;
        cord.clear();
        for (int i=0; i<N; ++i) {
            double x, y;
            RL();
            sscanf(buff,"%lf%lf", &x, &y);
            cord.push_back(make_pair(x,y));
            max_measure = max(max_measure, abs(x));
            max_measure = max(max_measure, abs(y));
        }
        pair< pair<double,double> , double> res = brute(1e12);
        printf("%.2lf %.2lf %.2lf\n" , res.first.first, res.first.second, res.second);
    }

    return 0;
}
{% endhighlight%}
