---
layout: post
title: POJ 3468 -- A Simple Problem with Integers
date: 2017-07-15 21:00
comments: true
external-url:
tags: segment_tree, rmq
---

線段樹

A simple problem? 當真?

（雖然是個模板題...）

## 解法

就是線段樹模板題，需要建出一棵支援區間修改、區間查詢的線段樹。

使用懶標記實現。

本題測資範圍較大，必須開 long long int。

還有使用 `cin`, `cout` 時，

請配合

```
    ios::sync_with_stdio(false);
    cin.tie(0);
```

使用，以免 `TLE`

## 傳送門

[POJ3468](http://poj.org/problem?id=3468)


## 程式碼

{% highlight cpp linenos=table %}

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

char buff[50000000];
long long int seg[500100];
long long int lazy[500100];

void init() {
    memset(buff,0x00,sizeof(buff));
    memset(seg,0x00,sizeof(seg));
    memset(lazy,0x00,sizeof(lazy));
}

void push(int idx, int L, int M, int R) {
    if(lazy[idx]==0LL) return;
    // 壓懶標記
    lazy[idx<<1] += lazy[idx];
    lazy[idx<<1|1] += lazy[idx];
    seg[idx<<1] += lazy[idx]*(long long int)(M-L+1);
    seg[idx<<1|1] += lazy[idx]*(long long int)(R-M);
    lazy[idx] = 0LL; // reset lz tag
}

void pull(int idx, int L, int M, int R) {
    seg[idx] = seg[idx<<1|1]+seg[idx<<1];
}

void update(int L, int R, int qL, int qR, int idx, long long int val) {
    if (L>qR || R<qL) return;
    if (L>=qL && R<=qR) {
        seg[idx]+=(val*(R-L+1));
        lazy[idx]+=val;
        return; // 放懶標
    }
    int M = L+((R-L)>>1);
    push(idx, L, M, R);
    update(L, M, qL, qR, idx<<1, val);
    update(M+1, R, qL, qR, idx<<1|1, val);
    pull(idx, L, M, R);
}

long long query(int L, int R, int qL, int qR, int idx) {
    if (L>qR || R<qL) return 0LL;
    if (L>=qL && R<=qR) return seg[idx];
    int M = L+((R-L)>>1);
    push(idx, L, M, R);
    long long l=0, r=0;
    l = query(L,M,qL,qR,idx<<1);
    r = query(M+1,R,qL,qR,idx<<1|1);
    pull(idx, L, M, R);
    return l+r;
}

#define RL() fgets(buff, sizeof(buff)-100, stdin)
int main(void) {
    int N, Q, i;
    char *readPtr=NULL;
    RL();
    sscanf(buff, "%d%d", &N, &Q);
    RL();
    i=1;
    readPtr = strtok(buff, " \n");
    while(readPtr) {
        long long int input=0;
        sscanf(readPtr, "%lld", &input);
        update(1, N, i, i, 1, input);
        readPtr = strtok(NULL, " \n");
        ++i;
    }
    while(Q--) {
        char op;
        int l, r;
        long long int x;
        RL();
        int cnt = sscanf(buff, "%1c %d %d %lld", &op, &l, &r, &x);
        if (cnt==4) { //update
            update(1, N, l, r, 1, x);
        } else {
            printf("%lld\n", query(1,N,l,r,1));
        }
    }

    return 0;
}

{% endhighlight %}

## 類題 ZeroJudge d799

[ZJd799 傳送門](https://zerojudge.tw/ShowProblem?problemid=d799)

{% highlight cpp linenos=table %}

#include <cstring>

struct SegmentTree {
    enum{ MAXN=500010, TREEND=3, TREENN=MAXN*TREEND};
    long long int  seg[TREENN]; // neg, pos
    long long int lazy[TREENN];  // neg, pos

//#define HALF_OPEN_INTERVAL
#define LEFT(i) ((i)<<1)
#define RIGHT(i) ((i)<<1|1)

    inline void init(int n) {
        using std::memset;
        n *= TREEND;
        memset(this->seg, 0x00, sizeof(this->seg[0])*(n+1));
        memset(this->lazy, 0x00, sizeof(this->lazy[0])*(n+1));
    }

#ifndef HALF_OPEN_INTERVAL
    // 節點紀錄閉區間   [, ]
#define IN_RANGE (qL<=L && qR>=R)
#define OO_RANGE (L>qR || R<qL)
#else
    // 節點紀錄半開區間 [, )
#define IN_RANGE (qL<=L && qR>=R)
#define OO_RANGE (L>=qR || R<=qL)
#endif

    inline void _push(int lev, int L, int M, int R) {
        if (lazy[lev]==0LL) return; // 有懶標記，我底下的子樹還沒更新
        if (L<=M) {
            lazy[LEFT(lev)] += lazy[lev];
            seg[LEFT(lev)] += lazy[lev]*((long long int)(M-L+1)); // 把懶標往下壓，左右子樹更新答案
        }
        if (R> M) {
            lazy[RIGHT(lev)] += lazy[lev];
            seg[RIGHT(lev)]+= lazy[lev]*((long long int)(R-M));
        }
        lazy[lev] = 0LL;
    }

    // 更新
    inline void _pull(int lev, int L, int M, int R) {
        seg[lev] = 0LL;
        if (L<=M)
            seg[lev] += seg[LEFT(lev)]; // 回傳更新後答案
        if (R> M)
            seg[lev] += seg[RIGHT(lev)];
    }

    void update(int L, int R, int qL, int qR, int lev, long long int op) {
        if (OO_RANGE) return;
        int M = (L+R)>>1;
        if (IN_RANGE) {
            lazy[lev] += op; // 懶標記
            seg[lev]  += op*(long long int)(R-L+1); // 更新現在的區間，底下子樹還沒更新
            return;
        }
        _push(lev, L, M, R);
        update(L, M, qL, qR, LEFT(lev), op);
#ifndef HALF_OPEN_INTERVAL
        update(M+1, R, qL,qR, RIGHT(lev),op);
#else
        update(M, R, qL,qR, RIGHT(lev),op);
#endif
        _pull(lev, L, M, R);
    }

    long long int query(int L, int R, int qL, int qR, int flag) {
        int M=(L+R)>>1;
        if (OO_RANGE) return 0LL; // 沒東西
        if (IN_RANGE) return seg[flag];
        _push(flag, L, M, R); // 查詢之前，必須保證這個節點底下的左右子樹是正確的
        long long int left = 0LL, right = 0LL;
        left = query(L,M,qL,qR,LEFT(flag));
#ifndef HALF_OPEN_INTERVAL
        right= query(M+1,R,qL,qR,RIGHT(flag));
#else
        right= query(M,R,qL,qR,RIGHT(flag));
#endif
        _pull(flag, L, M, R); // if update (optional)
        return left+right; // if update (optional)
        //return operationOnPull<int>(left, right); // not update
    }
#undef IN_RANGE
#undef OO_RANGE
#undef LEFT
#undef RIGHT
#undef HALF_OPEN_INTERVAL
};

#include <iostream>
#include <cassert>
using namespace std;

int main(void) {
    ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
    int N, Q;
    cin >> N;
    SegmentTree *T=NULL;
    T = new SegmentTree;
    assert(T!=NULL);
    SegmentTree &tree = *T;
    tree.init(N);
    for (int i=1; i<=N; ++i) {
        long long int input;
        cin >> input;
        tree.update(1, N, i, i, 1, input);
    }
    cin >> Q;
    while(Q--) {
        int op;
        int l, r;
        long long int x;
        cin >> op >> l >> r;
        switch (op) {
            case 1: {
                    cin >> x;
                    tree.update(1, N, l, r, 1, x);
                }
                break;
            case 2: {
                    cout << tree.query(1, N, l, r, 1) << '\n';
                }
                break;
        }
    }
    delete T;
    return 0;
}


{% endhighlight %}
